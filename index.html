<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lukis Bareng AI</title>
    <link rel="stylesheet" href="style.css" />
    <script src="stencils.js"></script>
    <script src="autodraw.js"></script>
    <script src="autodraw-ui.js"></script>
  </head>
  <body>
    <!-- <h1>🎨 Lukis Bareng AI 🎨</h1>  -->
    <div class="layout">
      <aside class="sidebar">
        <div class="controls">
          <h3>🎨 Pilih Warna</h3>
          <div class="color-picker">
            <div
              class="color-option active"
              data-color="black"
              style="background-color: black"
            ></div>
            <div
              class="color-option"
              data-color="blue"
              style="background-color: #2196f3"
            ></div>
            <div
              class="color-option"
              data-color="red"
              style="background-color: #f44336"
            ></div>
          </div>
          <h3>🧽 Alat</h3>
          <div class="tools">
            <button class="tool-btn active" data-tool="brush" title="Kuas">
              <img src="assets/pencil.svg" alt="Kuas" width="28" height="28" />
            </button>
            <button class="tool-btn" data-tool="eraser" title="Hapus">
              <img src="assets/eraser.svg" alt="Hapus" width="28" height="28" />
            </button>
            <button
              class="clear-btn"
              onclick="clearCanvas()"
              title="Hapus Semua"
            >
              <img
                src="assets/trash.svg"
                alt="Hapus Semua"
                width="28"
                height="28"
              />
            </button>
          </div>
        </div>
      </aside>
      <main class="main-content">
        <canvas id="draw" width="768" height="512"></canvas>
        <div class="prompt-section">
          <div class="prompt-row">
            <input
              id="customPrompt"
              class="prompt-input"
              type="text"
              placeholder="Tulis instruksi untuk AI di sini..."
              value="Redraw the black scribble as a clean, creative, bold vector-style image. Keep the main subject and shape, but use only solid black on white, no shading, no textures, no colors"
            />
            <button class="send-btn" onclick="sendToAI()">
              ✨ Kirim ke AI ✨
            </button>
          </div>
        </div>
        <div class="canvas-controls">
          <button
            class="reset-btn"
            onclick="resetCanvas()"
            style="display: none"
          >
            🔄 Gambar Lagi
          </button>
        </div>
      </main>
      <aside class="predictions-sidebar">
        <div id="autodraw-container"></div>
      </aside>
    </div>
    <script>
      const canvas = document.getElementById("draw");
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let drawing = false;
      let lastX = 0;
      let lastY = 0;
      let currentColor = "black";
      let currentTool = "brush";
      let brushSize = 8; // Diperbesar dari 16 ke 32
      let originalImageData = null; // Store original drawing
      let isShowingAIResult = false;

      // Initialize AutoDraw
      const autoDraw = new AutoDraw(canvas);
      const autoDrawUI = new AutoDrawUI(
        document.getElementById("autodraw-container")
      );

      // Set up AutoDraw callbacks
      autoDraw.setPredictionCallback((predictions) => {
        autoDrawUI.updatePredictions(predictions);
      });

      // Function to draw SVG to canvas
      async function drawSvgToCanvas(svgUrl, prediction) {
        try {
          // Clear canvas first
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Create image directly from SVG URL (works better with CORS)
          const img = new Image();
          img.crossOrigin = "anonymous";

          img.onload = function () {
            // Calculate scaling to fit canvas while maintaining aspect ratio
            const scale =
              Math.min(canvas.width / img.width, canvas.height / img.height) *
              0.7; // 0.7 for padding
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (canvas.width - scaledWidth) / 2;
            const y = (canvas.height - scaledHeight) / 2;

            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);

            // Clear AutoDraw strokes since we replaced with stencil
            autoDraw.clearStrokes();

            console.log(`Stencil "${prediction}" berhasil digambar di canvas`);
          };

          img.onerror = function () {
            console.error("Error loading SVG:", svgUrl);
            // Fallback: draw text
            ctx.fillStyle = currentColor;
            ctx.font = "48px Comic Sans MS";
            ctx.textAlign = "center";
            ctx.fillText(prediction, canvas.width / 2, canvas.height / 2);
            autoDraw.clearStrokes();
          };

          img.src = svgUrl;
        } catch (error) {
          console.error("Error drawing SVG:", error);
          // Fallback: draw text
          ctx.fillStyle = currentColor;
          ctx.font = "48px Comic Sans MS";
          ctx.textAlign = "center";
          ctx.fillText(prediction, canvas.width / 2, canvas.height / 2);
          autoDraw.clearStrokes();
        }
      }

      autoDrawUI.setOnSelectCallback((prediction, stencilIndex = -1) => {
        // Check if stencil exists for this prediction
        if (
          window.stencils &&
          window.stencils[prediction] &&
          window.stencils[prediction].length > 0
        ) {
          let stencil;
          
          if (stencilIndex >= 0 && stencilIndex < window.stencils[prediction].length) {
            // Use specific stencil if index is provided
            stencil = window.stencils[prediction][stencilIndex];
          } else {
            // Randomly select one stencil if no specific index
            const stencils = window.stencils[prediction];
            const randomIndex = Math.floor(Math.random() * stencils.length);
            stencil = stencils[randomIndex];
          }

          console.log(
            `Drawing stencil for "${prediction}" from collection: ${stencil.collection}`
          );
          drawSvgToCanvas(stencil.src, prediction);
        } else {
          // Fallback if no stencil found
          console.log("No stencil found for:", prediction);
          // Draw text as fallback
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = currentColor;
          ctx.font = "48px Comic Sans MS";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(prediction, canvas.width / 2, canvas.height / 2);
          autoDraw.clearStrokes();
        }
      });

      autoDrawUI.setOnToggleCallback((enabled) => {
        autoDraw.setEnabled(enabled);
      });

      // Initialize color picker
      const colorOptions = document.querySelectorAll(".color-option");
      const toolButtons = document.querySelectorAll(".tool-btn");

      colorOptions.forEach((option) => {
        option.addEventListener("click", () => {
          colorOptions.forEach((opt) => opt.classList.remove("active"));
          option.classList.add("active");
          currentColor = option.dataset.color;
          if (currentTool === "brush") {
            ctx.globalCompositeOperation = "source-over";
          }
        });
      });

      toolButtons.forEach((button) => {
        button.addEventListener("click", () => {
          toolButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          const newTool = button.dataset.tool;
          
          currentTool = newTool;

          if (currentTool === "eraser") {
            ctx.globalCompositeOperation = "destination-out";
            brushSize = 30; // Diperbesar dari 15 ke 30
          } else {
            ctx.globalCompositeOperation = "source-over";
            brushSize = 12; // Diperbesar dari 4 ke 12
          }
          
          console.log('Switched to tool:', currentTool);
        });
      });

      canvas.addEventListener("mousedown", (e) => {
        if (isShowingAIResult) return; // Prevent drawing on AI result
        drawing = true;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        lastX = (e.clientX - rect.left) * scaleX;
        lastY = (e.clientY - rect.top) * scaleY;

        // Start AutoDraw stroke
        autoDraw.startStroke(lastX, lastY);
      });

      canvas.addEventListener("mouseup", () => {
        if (drawing) {
          drawing = false;
          // End AutoDraw stroke
          autoDraw.endStroke();
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!drawing || isShowingAIResult) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const currentX = (e.clientX - rect.left) * scaleX;
        const currentY = (e.clientY - rect.top) * scaleY;

        ctx.lineWidth = brushSize;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        if (currentTool === "brush") {
          ctx.strokeStyle = currentColor;
          ctx.globalCompositeOperation = "source-over";
          // Add to AutoDraw stroke only when drawing, not erasing
          autoDraw.addToStroke(currentX, currentY);
        } else if (currentTool === "eraser") {
          // Set eraser mode - predictions tetap ada
          ctx.globalCompositeOperation = "destination-out";
        }

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();

        lastX = currentX;
        lastY = currentY;
      });

      // Touch events for mobile devices
      canvas.addEventListener("touchstart", (e) => {
        if (isShowingAIResult) return; // Prevent drawing on AI result
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const touch = e.touches[0];
        drawing = true;
        lastX = (touch.clientX - rect.left) * scaleX;
        lastY = (touch.clientY - rect.top) * scaleY;

        // Start AutoDraw stroke
        autoDraw.startStroke(lastX, lastY);
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        if (drawing) {
          drawing = false;
          // End AutoDraw stroke
          autoDraw.endStroke();
        }
      });

      canvas.addEventListener("touchmove", (e) => {
        if (isShowingAIResult) return; // Prevent drawing on AI result
        e.preventDefault();
        if (!drawing) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const touch = e.touches[0];
        const currentX = (touch.clientX - rect.left) * scaleX;
        const currentY = (touch.clientY - rect.top) * scaleY;

        ctx.lineWidth = brushSize;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        if (currentTool === "brush") {
          ctx.strokeStyle = currentColor;
          ctx.globalCompositeOperation = "source-over";
          // Add to AutoDraw stroke only when drawing, not erasing
          autoDraw.addToStroke(currentX, currentY);
        } else if (currentTool === "eraser") {
          // Set eraser mode - predictions tetap ada
          ctx.globalCompositeOperation = "destination-out";
        }

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();

        lastX = currentX;
        lastY = currentY;
      });

      function clearCanvas() {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Reset canvas composite operation to normal drawing mode
        ctx.globalCompositeOperation = "source-over";
        
        // Clear AutoDraw strokes dan predictions PERTAMA
        autoDraw.clearStrokes();
        autoDrawUI.clearPredictions();
        
        // Kemudian reset mode drawing
        resetToDrawingMode();
        
        console.log('Canvas cleared completely');
      }

      function resetToDrawingMode() {
        isShowingAIResult = false;
        document.getElementById("canvas-title").textContent = "🎨 Gambar Kamu";
        document.querySelector(".send-btn").style.display = "inline-block";
        document.querySelector(".reset-btn").style.display = "none";
        canvas.style.cursor = "crosshair";
      }

      function resetCanvas() {
        if (originalImageData) {
          ctx.putImageData(originalImageData, 0, 0);
          resetToDrawingMode();
          // Clear AutoDraw strokes dan predictions saat reset
          autoDraw.clearStrokes();
          autoDrawUI.clearPredictions();
        }
      }

      async function sendToAI() {
        // Store original drawing
        originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        // Get custom prompt
        const customPrompt = document
          .getElementById("customPrompt")
          .value.trim();
        if (!customPrompt) {
          alert("Silakan masukkan prompt terlebih dahulu! 📝");
          return;
        }

        // Show loading state
        const button = document.querySelector(".send-btn");
        const resetBtn = document.querySelector(".reset-btn");
        const title = document.getElementById("canvas-title");

        button.textContent = "⏳ AI sedang bekerja...";
        button.disabled = true;
        title.textContent = "🤖 AI Sedang Melukis...";
        canvas.style.cursor = "wait";

        try {
          // Convert canvas to blob
          const dataURL = canvas.toDataURL("image/png");
          const blob = await (await fetch(dataURL)).blob();

          // Prepare form data
          const formData = new FormData();
          formData.append("file", blob, "drawing.png");
          formData.append("prompt", customPrompt);

          // Send to AI backend
          const response = await fetch(
            "https://b08646fccc6c.ngrok-free.app/generate",
            {
              method: "POST",
              body: formData,
              headers: {
                "ngrok-skip-browser-warning": "true",
              },
            }
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const result = await response.json();

          // Handle base64 response from your backend
          if (result.image) {
            // Create new image and draw it on canvas
            const img = new Image();
            img.onload = function () {
              // Clear canvas and draw AI result
              ctx.fillStyle = "white";
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              // Draw the AI result to fit canvas
              const scale = Math.min(
                canvas.width / img.width,
                canvas.height / img.height
              );
              const x = (canvas.width - img.width * scale) / 2;
              const y = (canvas.height - img.height * scale) / 2;

              ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

              // Update UI
              isShowingAIResult = true;
              title.textContent = "✨ Hasil AI";
              button.style.display = "none";
              resetBtn.style.display = "inline-block";
              canvas.style.cursor = "default";
            };
            img.src = `data:image/png;base64,${result.image}`;
          } else {
            throw new Error("No image received from AI");
          }
        } catch (error) {
          console.error("Error sending to AI:", error);
          alert(
            "Maaf, terjadi kesalahan saat mengirim ke AI. Pastikan gambar sudah ada dan coba lagi ya! 😊"
          );
        } finally {
          // Reset button state
          button.textContent = "✨ Kirim ke AI ✨";
          button.disabled = false;
        }
      }

      // Fungsi threshold: ubah canvas jadi hitam-putih
      function thresholdCanvas(threshold = 180) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          // Ambil brightness (rata-rata RGB)
          const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
          if (avg < threshold) {
            // Hitam
            data[i] = 0;
            data[i + 1] = 0;
            data[i + 2] = 0;
          } else {
            // Putih
            data[i] = 255;
            data[i + 1] = 255;
            data[i + 2] = 255;
          }
        }
        ctx.putImageData(imageData, 0, 0);
      }

      // --- Integrasi threshold HANYA untuk prediksi final ---
      // Simpan referensi asli AutoDraw getPredictions
      const originalGetPredictions = autoDraw.getPredictions.bind(autoDraw);
      autoDraw.getPredictions = async function () {
        // Simpan canvas state saat ini
        const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Terapkan threshold untuk prediksi yang lebih baik
        thresholdCanvas(180);
        
        // Panggil prediksi asli
        await originalGetPredictions();
        
        // Kembalikan canvas ke state semula
        ctx.putImageData(currentImageData, 0, 0);
      };
    </script>
  </body>
</html>
